
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11. API documentation of ana_cont &#8212; ana_cont 1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="10. Maxent for matrix-valued Green’s functions" href="poorman_test.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="api-documentation-of-ana-cont">
<h1><span class="section-number">11. </span>API documentation of ana_cont<a class="headerlink" href="#api-documentation-of-ana-cont" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-ana_cont.continuation">
<span id="continuation-module"></span><h2><span class="section-number">11.1. </span>Continuation module<a class="headerlink" href="#module-ana_cont.continuation" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="ana_cont.continuation.AnalyticContinuationProblem">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.continuation.</code><code class="sig-name descname">AnalyticContinuationProblem</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im_axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">re_axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">im_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_mode</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.continuation.AnalyticContinuationProblem" title="Permalink to this definition">¶</a></dt>
<dd><p>Specification of an analytic continuation problem.</p>
<p>This class is designed to hold the information that specifies the analytic continuation problem:</p>
<ul class="simple">
<li><p>Imaginary axis of the data</p></li>
<li><p>Real axis on which the result is anticipated</p></li>
<li><p>Imaginary-axis data (real-valued array)</p></li>
<li><p>Type of kernel (fermionic, bosonic, time, frequency)</p></li>
<li><p>Inverse temperature beta (only necessary for time kernels)</p></li>
</ul>
<p>Furthermore the class provides an interface to call the solver.</p>
<p>Create instance of AnalyticContinuationProblem</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im_axis</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of type float
Matsubara frequencies or imaginary time points of the input data.</p></li>
<li><p><strong>re_axis</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of type float
Real-frequency grid to use for the analytic continuation.</p></li>
<li><p><strong>im_data</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of type float or complex
Imaginary-axis data, e.g. Matsubara Green’s function</p></li>
<li><p><strong>kernel_mode</strong> ({<cite>‘freq_fermionic’</cite>, <cite>‘freq_bosonic’</cite>, <cite>‘time_fermionic’</cite>, <cite>‘time_bosonic’</cite>}) – <ul>
<li><p><cite>‘freq_fermionic’</cite> fermionic Matsubara Greens function</p></li>
<li><p><cite>’freq_bosonic’</cite> bosonic Matsubara Greens function</p></li>
<li><p><cite>’time_fermionic’</cite> fermionic Green’s function in imaginary time</p></li>
<li><p><cite>’time_bosonic’</cite> bosonic Green’s function (susceptibility) in imaginary time</p></li>
</ul>
</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – Inverse temperature (only necessary for time kernels)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ana_cont.continuation.AnalyticContinuationProblem.partial_solution">
<code class="sig-name descname">partial_solution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.continuation.AnalyticContinuationProblem.partial_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Maxent optimization at a specific value of alpha.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.continuation.AnalyticContinuationProblem.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.continuation.AnalyticContinuationProblem.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface function for solving the analytic continuation problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> – Analytic continuation method, possible choices are ‘maxent_svd’, ‘pade’</p></li>
<li><p><strong>kwargs</strong> – Further keyword arguments, specific to the solution method</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>OptimizationResult object</p>
</dd>
</dl>
<p>This function first creates an instance of an AnalyticContinuationSolver object,
then the respective solve function is called.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ana_cont.continuation.GreensFunction">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.continuation.</code><code class="sig-name descname">GreensFunction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectrum</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wgrid</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.continuation.GreensFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This class defines a GreensFunction object. The main use of this
is to calculate a full Green’s function with real- and imaginary part
from a spectrum.</p>
<p>Initialize with spectral function and real-frequency grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spectrum</strong> (<em>np.ndarray</em>) – numpy array containing the spectral function</p></li>
<li><p><strong>wgrid</strong> (<em>np.ndarray</em>) – one-dimensional numpy array of type float
real-frequency values corresponding to the <cite>spectrum</cite></p></li>
<li><p><strong>kind</strong> ({<cite>‘fermionic’</cite>, <cite>‘bosonic’</cite>}) – specify if the Green’s function is fermionic or bosonic.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ana_cont.continuation.GreensFunction.kkt">
<code class="sig-name descname">kkt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.continuation.GreensFunction.kkt" title="Permalink to this definition">¶</a></dt>
<dd><p>Kramers Kronig transformation</p>
<p>Obtain full complex Green’s function from its imaginary part.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ana_cont.solvers">
<span id="solvers-module"></span><h2><span class="section-number">11.2. </span>Solvers module<a class="headerlink" href="#module-ana_cont.solvers" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="ana_cont.solvers.AnalyticContinuationSolver">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.solvers.</code><code class="sig-name descname">AnalyticContinuationSolver</code><a class="headerlink" href="#ana_cont.solvers.AnalyticContinuationSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for solver classes.</p>
<p>Each Solver class has to inherit from this class.
The purpose of this is to ensure that each child class
has a method ‘solve’ implemented.</p>
</dd></dl>

<dl class="py class">
<dt id="ana_cont.solvers.MaxentSolverSVD">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.solvers.</code><code class="sig-name descname">MaxentSolverSVD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im_axis</span></em>, <em class="sig-param"><span class="n">re_axis</span></em>, <em class="sig-param"><span class="n">im_data</span></em>, <em class="sig-param"><span class="n">kernel_mode</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stdev</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cov</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">offdiag</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">preblur</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">blur_width</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">'newton'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Maxent with singular-value decomposition.</p>
<p>The singular-value decomposition of the kernel leads to a basis
in which the dimensionality of the analytic continuation problem
is much reduced. This makes computations faster and enforces some
constraints.</p>
<p>This class is never instantiated directly by the user, but instead by
the solve method of continuation.AnalyticContinuationProblem.</p>
<p>Create a Maxent solver object.</p>
<p>Here we pass the data to the solver and do some precomputations.
This makes the process of solving much faster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im_axis</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of type float
Matsubara frequencies or imaginary time points of the input data.</p></li>
<li><p><strong>re_axis</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of type float
Real-frequency grid to use for the analytic continuation.</p></li>
<li><p><strong>im_data</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of type float or complex
Imaginary-axis data, e.g. Matsubara Green’s function</p></li>
<li><p><strong>kernel_mode</strong> ({<cite>‘freq_fermionic’</cite>, <cite>‘freq_bosonic’</cite>, <cite>‘time_fermionic’</cite>, <cite>‘time_bosonic’</cite>}) – <ul>
<li><p><cite>‘freq_fermionic’</cite> fermionic Matsubara Greens function</p></li>
<li><p><cite>’freq_bosonic’</cite> bosonic Matsubara Greens function</p></li>
<li><p><cite>’time_fermionic’</cite> fermionic Green’s function in imaginary time</p></li>
<li><p><cite>’time_bosonic’</cite> bosonic Green’s function (susceptibility) in imaginary time</p></li>
</ul>
<p>Additionally there are less established special-purpose options
[<cite>‘freq_bosonic_xyz’</cite>, <cite>‘freq_fermionic_phsym’</cite>, <cite>‘time_fermionic_phsym’</cite>].</p>
</p></li>
<li><p><strong>model</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of type float.
(Values must be greater or equal to zero.)
Default model of the Maxent calculation, i.e. the entropy of the
spectral function is computed with respect to this model.
Thus the shape has to match <cite>re_axis</cite>.</p></li>
<li><p><strong>stdev</strong> (<em>numpy.ndarray</em>) – One-dimensional numpy array of positive float values.
<cite>stdev</cite> are the standard deviation values of the measured data points,
thus they have to be larger than zero. The shape has to match <cite>im_data</cite>
The keywords <cite>stdev</cite> and <cite>cov</cite> are mutually exclusive, i.e. only one of them
can be used.
For complex data (e.g. Matsubara Green’s function) the same standard deviation
is used for both the real and imaginary part, such that the array passed to this
keyword is taken as the standard deviation of the real part (not the absolute).</p></li>
<li><p><strong>cov</strong> (<em>numpy.ndarray</em>) – Two-dimensional numpy array.
<cite>cov</cite> is the covariance matrix of the input data. If it is diagonal, the diagonal
elements are the variance of the data, i.e. the square of the standard deviation.
The keywords <cite>stdev</cite> and <cite>cov</cite> are mutually exclusive, i.e. only one of them
can be used.
For complex data, the covariance matrix can be complex (see Kappl et al., PRB 102 (8), 085124)</p></li>
<li><p><strong>offdiag</strong> (<em>bool</em><em>, </em><em>default: False</em>) – Whether the input data are offdiagonal elements of a matrix. For diagonal elements,
the spectral function is positive, for offdiagonal ones it has positive and negative
values, and the integral is 0.</p></li>
<li><p><strong>preblur</strong> (<em>bool</em><em>, </em><em>default: False</em>) – Whether to use preblur in the calculation</p></li>
<li><p><strong>blur_width</strong> (<em>float</em><em>, </em><em>default: 0.</em>) – If preblur=True, specify a width of the preblur that is larger than 0.</p></li>
<li><p><strong>optimizer</strong> (<em>{'scipy_lm'</em><em>, </em><em>'newton'}</em><em>, </em><em>default: 'newton'</em>) – Which optimizer to use at each value of alpha to solve the minimization / root finding problem.
Usually the custom implementation of the newton algorithm is much faster.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default: True</em>) – If set to False, no output is printed. This can be useful when doing a very large number
of computations, but generally I recommend leaving it on True, to see what is happening.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.backtransform">
<code class="sig-name descname">backtransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.backtransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Backtransformation from real to imaginary axis.</p>
<p><span class="math notranslate nohighlight">\(G(i\omega_n) = \int d\nu \; K(i\omega_n, \nu)  A(\nu)\)</span></p>
<p>Also at this place we return from the ‘diagonal-covariance space’
Note: this function is not a bottleneck.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>numpy.ndarray</em>) – Spectral function</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Back-transformed Green’s function on imaginary axis</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.bayes_conv">
<code class="sig-name descname">bayes_conv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">entr</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.bayes_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian convergence criterion for classic maxent (maximum of probablility distribution)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – spectral function</p></li>
<li><p><strong>entr</strong> (<em>float</em>) – entropy</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – weight factor of the entropy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ng</strong> (<em>float</em>) – “number of good data points”</p></li>
<li><p><strong>tr</strong> (<em>float</em>) – trace of the gamma matrix</p></li>
<li><p><strong>conv</strong> (<em>float</em>) – convergence criterion (1 -&gt; converged)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.bayes_conv_offdiag">
<code class="sig-name descname">bayes_conv_offdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">entr</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.bayes_conv_offdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian convergence criterion for classic maxent, offdiagonal version</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – spectral function</p></li>
<li><p><strong>entr</strong> (<em>float</em>) – entropy</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – weight factor of the entropy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ng</strong> (<em>float</em>) – “number of good data points”</p></li>
<li><p><strong>tr</strong> (<em>float</em>) – trace of the gamma matrix</p></li>
<li><p><strong>conv</strong> (<em>float</em>) – convergence criterion (1 -&gt; converged)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.chi2">
<code class="sig-name descname">chi2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>compute chi-squared-deviation</p>
<p>Compute the log-likelihood function or chi-squared-deviation of
the spectral function:
<span class="math notranslate nohighlight">\(\sum_n \frac{|G(i\omega_n) - \int K(i\omega_n, \nu) A(\nu)|^2}{\sigma_n^2}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>numpy.ndarray</em>) – Spectral function</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>chi-squared deviation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.compute_f_J_diag">
<code class="sig-name descname">compute_f_J_diag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.compute_f_J_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>This function evaluates the function whose root we want to find.</p>
<p>The function <span class="math notranslate nohighlight">\(f_m(u)\)</span> is defined as the singular value decomposition
of the derivative <span class="math notranslate nohighlight">\(dQ[A]/dA_m\)</span>. Since we want to minimize <span class="math notranslate nohighlight">\(Q[A]\)</span>,
we have to find the root of the vector-valued function <span class="math notranslate nohighlight">\(f\)</span>, i.e.
<span class="math notranslate nohighlight">\(f_m(u) = SVD(dQ/dA)_m = 0\)</span>.
For more efficient root finding, we also need the Jacobian <span class="math notranslate nohighlight">\(J\)</span>.
It is directly computed in singular space, <span class="math notranslate nohighlight">\(J_{mi}=df_m/du_i\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>numpy.ndarray</em>) – singular-space vector that parametrizes the spectral function</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – (positive) weight factor of the entropy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>f</strong> (<em>numpy.ndarray</em>) – value of the function whose zero we want to find</p></li>
<li><p><strong>J</strong> (<em>numpy.ndarray</em>) – Jacobian at the current position</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.compute_f_J_offdiag">
<code class="sig-name descname">compute_f_J_offdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.compute_f_J_offdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>The analogue to compute_f_J_diag for offdiagonal elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>numpy.ndarray</em>) – singular-space vector that parametrizes the spectral function</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – (positive) weight factor of the entropy</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>f</strong> (<em>numpy.ndarray</em>) – value of the function whose zero we want to find</p></li>
<li><p><strong>J</strong> (<em>numpy.ndarray</em>) – Jacobian at the current position</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.entropy_pos">
<code class="sig-name descname">entropy_pos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.entropy_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute entropy for positive definite spectral function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – Spectral function</p></li>
<li><p><strong>u</strong> (<em>numpy.ndarray</em>) – Singular-space vector representing the same spectral function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>entropy</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.entropy_posneg">
<code class="sig-name descname">entropy_posneg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.entropy_posneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute “positive-negative entropy” for spectral function with norm 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – Spectral function</p></li>
<li><p><strong>u</strong> (<em>numpy.ndarray</em>) – Singular-space vector representing the same spectral function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>entropy</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.error_propagation">
<code class="sig-name descname">error_propagation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obs</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.error_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the deviation for a callable function obs.
This feature is still experimental</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Print log messages if <cite>verbose=True</cite> was passed to the solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong> (<em>str</em>) – Message to print</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.maxent_optimization">
<code class="sig-name descname">maxent_optimization</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">ustart</span></em>, <em class="sig-param"><span class="n">iterfac</span><span class="o">=</span><span class="default_value">10000000</span></em>, <em class="sig-param"><span class="n">use_bayes</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.maxent_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>optimization of maxent functional for a given value of alpha</p>
<p>Since a priori the best value of <span class="math notranslate nohighlight">\(\alpha\)</span> is unknown,
this function has to be called several times in order to find a good value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – weight factor of the entropy</p></li>
<li><p><strong>ustart</strong> (<em>numpy.ndarray</em>) – singular-space vector used as a starting value for the optimization.
For the first optimization, done at large alpha, we use zeros,
which corresponds to the default model. Then we use the result of the
previous optimization as a starting value.</p></li>
<li><p><strong>iterfac</strong> (<em>int</em><em>, </em><em>default: 10000000</em>) – Control parameter for maximum number of iterations in
scipy_lm, which is &lt;number of singular values&gt; * iterfac.
It has no effect when using the newton optimizer.</p></li>
<li><p><strong>use_bayes</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to use the Bayesian inference parameters for alpha.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Object that holds the results of the optimization,
e.g. spectral function, chi-squared deviation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ana_cont.solvers.OptimizationResult" title="ana_cont.solvers.OptimizationResult">OptimizationResult</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.posterior_probability">
<code class="sig-name descname">posterior_probability</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">entr</span></em>, <em class="sig-param"><span class="n">chisq</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.posterior_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian a-posteriori probability for alpha after optimization of A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – spectral function</p></li>
<li><p><strong>entr</strong> (<em>float</em>) – entropy</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – weight factor of the entropy</p></li>
<li><p><strong>chisq</strong> (<em>float</em>) – chi-squared deviation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Probability</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.singular_to_realspace_diag">
<code class="sig-name descname">singular_to_realspace_diag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.singular_to_realspace_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Go from singular to real space.</p>
<p>Transform the singular space vector u into real-frequency space (spectral function)
by <span class="math notranslate nohighlight">\(A(\omega) = D(\omega) e^{V u}\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> is the default model
and <span class="math notranslate nohighlight">\(V\)</span> is the matrix from the SVD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>numpy.ndarray</em>) – singular-space vector that parametrizes the spectral function</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral function <span class="math notranslate nohighlight">\(A\)</span> obtained from <cite>u</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.singular_to_realspace_offdiag">
<code class="sig-name descname">singular_to_realspace_offdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.singular_to_realspace_offdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Go from singular to real space.</p>
<p>Transform the singular space vector u into real-frequency
space in the case of an offdiagonal element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u</strong> (<em>numpy.ndarray</em>) – singular-space vector that parametrizes the spectral function</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spectral function <span class="math notranslate nohighlight">\(A\)</span> obtained from <cite>u</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function for solve, which calls the chosen
method of alpha_determination.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.solve_bryan">
<code class="sig-name descname">solve_bryan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alphastart</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">alphadiv</span><span class="o">=</span><span class="default_value">1.1</span></em>, <em class="sig-param"><span class="n">interactive</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.solve_bryan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bryan’s method of determining the optimal spectrum.</p>
<p>Bryan’s maxent calculates an average of spectral functions,
weighted by their Bayesian probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alphastart</strong> (<em>float</em><em>, </em><em>default=500</em>) – Starting value of alpha. This is the largest value of alpha,
it is decreased during the calculation.</p></li>
<li><p><strong>alphadiv</strong> (<em>float</em><em>, </em><em>default=1.1</em>) – After each optimization, the current alpha is divided by this number.
Hence, the number has to be larger than 1.</p></li>
<li><p><strong>interactive</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to show a plot of the probability. (Needs matplotlib)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>OptimizationResult</em> – Contains the weighted average of all results</p></li>
<li><p><em>list</em> – List of OptimizationResult objects for all used values of alpha</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.solve_chi2kink">
<code class="sig-name descname">solve_chi2kink</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha_start</span><span class="o">=</span><span class="default_value">1000000000.0</span></em>, <em class="sig-param"><span class="n">alpha_end</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">alpha_div</span><span class="o">=</span><span class="default_value">10.0</span></em>, <em class="sig-param"><span class="n">fit_position</span><span class="o">=</span><span class="default_value">2.5</span></em>, <em class="sig-param"><span class="n">interactive</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.solve_chi2kink" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine optimal alpha by searching for the kink in log(chi2) (log(alpha))</p>
<p>We start with an optimization at a large value of alpha (<cite>alpha_start</cite>),
where we should get only the default model. Then, alpha is decreased
step-by-step, where <span class="math notranslate nohighlight">\(\alpha_{n+1} = \alpha_n / \alpha_{div}\)</span>, until the minimal
value of alpha_end is reached.
Then, we fit a function
<span class="math notranslate nohighlight">\(\phi(x; a, b, c, d) = a + b / [1 + exp(-d*(x-c))]\)</span>,
from which the optimal alpha is determined by
x_opt = c - <cite>fit_position</cite> / d; alpha_opt = 10^x_opt.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha_start</strong> (<em>float</em><em>, </em><em>default=1e9</em>) – Value of alpha where to start the procedure.
This is the largest value of alpha, it is subsequently decreased
in the algorithm.</p></li>
<li><p><strong>alpha_end</strong> (<em>float</em><em>, </em><em>default=1e-3</em>) – Last (smallest) value of alpha that is considered in the algorithm</p></li>
<li><p><strong>alpha_div</strong> (<em>float</em><em>, </em><em>default=10.</em>) – After each optimization, alpha is divided by alpha_div.
Thus it has to be larger than 1. The default value of 10 is
a good compromise of function and speed. You can take
smaller values if you are unsure or want to make fancy plots.</p></li>
<li><p><strong>fit_position</strong> (<em>float</em><em>, </em><em>default=2.5</em>) – Control parameter for under/overfitting.
In my experience, good values are usually between 2 and 2.5.
Smaller values lead to underfitting, which is sometimes desirable.
Larger values lead to overfitting, which should be avoided.</p></li>
<li><p><strong>interactive</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Decide whether to show a plot of chi2 vs alpha.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>OptimizationResult</em> – Result of the optimization at “best” alpha value</p></li>
<li><p><em>list</em> – List of OptimizationResult objects for all used values of alpha</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.solve_classic">
<code class="sig-name descname">solve_classic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.solve_classic" title="Permalink to this definition">¶</a></dt>
<dd><p>Classic maxent alpha determination.</p>
<p>Classic maxent uses Bayes statistics to approximately determine
the most probable value of alpha
We start at a large value of alpha, where the optimization yields basically the default model,
therefore u_opt is only a few steps away from ustart=0 (=default model)
Then we gradually decrease alpha, step by step moving away from the default model towards data fitting.
Using u_opt as ustart for the next (smaller) alpha brings a great speedup into this procedure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>OptimizationResult</em> – Result of the optimization at “best” alpha value</p></li>
<li><p><em>list</em> – List of OptimizationResult objects for all used values of alpha</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.MaxentSolverSVD.solve_historic">
<code class="sig-name descname">solve_historic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.MaxentSolverSVD.solve_historic" title="Permalink to this definition">¶</a></dt>
<dd><p>Historic Maxent: choose alpha in a way that chi^2 pprox N</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>OptimizationResult</em> – Result of the optimization at “best” alpha value</p></li>
<li><p><em>list</em> – List of OptimizationResult objects for all used values of alpha</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ana_cont.solvers.NewtonOptimizer">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.solvers.</code><code class="sig-name descname">NewtonOptimizer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">opt_size</span></em>, <em class="sig-param"><span class="n">max_hist</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">20000</span></em>, <em class="sig-param"><span class="n">initial_guess</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.NewtonOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Newton root finding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opt_size</strong> – number of variables (integer)</p></li>
<li><p><strong>max_hist</strong> – maximal history for mixing (integer)</p></li>
<li><p><strong>max_iter</strong> – maximum number of iterations for root finding</p></li>
<li><p><strong>initial_guess</strong> – initial guess for the root finding.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ana_cont.solvers.NewtonOptimizer.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function_and_jacobian</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.NewtonOptimizer.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Main function of Newton optimization.</p>
<p>This function implements the self-consistent iteration of the root finding.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sol.x is the result
sol.nfev is the number of function evaluations</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>collections.namedtuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.NewtonOptimizer.get_proposal">
<code class="sig-name descname">get_proposal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mixing</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.NewtonOptimizer.get_proposal" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose a new solution by linear mixing.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.NewtonOptimizer.iteration_function">
<code class="sig-name descname">iteration_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">proposal</span></em>, <em class="sig-param"><span class="n">function_vector</span></em>, <em class="sig-param"><span class="n">jacobian_matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.NewtonOptimizer.iteration_function" title="Permalink to this definition">¶</a></dt>
<dd><p>The function, whose fixed point we are searching.</p>
<p>This function generates the iteration procedure in the Newton root finding.
Basically, it computes the “result” from the “proposal”.
It has the form result = proposal + increment, but
since the increment may be large, we apply a reduction of step width in such cases.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ana_cont.solvers.OptimizationResult">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.solvers.</code><code class="sig-name descname">OptimizationResult</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u_opt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">A_opt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chi2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backtransform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">entropy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n_good</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">probability</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">convergence</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">trace</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Q</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">norm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">blur_width</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numerator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">denominator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numerator_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">denominator_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">check</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ivcheck</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">g_ret</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.OptimizationResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Object for holding the result of an optimization.</p>
<p>This class has no methods except the constructor,
it is thus essentially a collection of output numbers.</p>
<p>All member variables have None as default value, different solvers
override different variables. A_opt is always set, since it
is the main result of analytic continuation.</p>
</dd></dl>

<dl class="py class">
<dt id="ana_cont.solvers.PadeSolver">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.solvers.</code><code class="sig-name descname">PadeSolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im_axis</span></em>, <em class="sig-param"><span class="n">re_axis</span></em>, <em class="sig-param"><span class="n">im_data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.PadeSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Pade solver</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im_axis</strong> (<em>numpy.ndarray</em>) – Matsubara frequencies which are used for the continuation</p></li>
<li><p><strong>re_axis</strong> (<em>numpy.ndarray</em>) – Real-frequency points at which the Pade interpolant is evaluated</p></li>
<li><p><strong>im_data</strong> (Green’s function values at the given points <cite>im_axis</cite>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ana_cont.solvers.PadeSolver.check">
<code class="sig-name descname">check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im_axis_fine</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.PadeSolver.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check for Pade approximant</p>
<p>Evaluate the Pade approximant on the imaginary axis,
however not only at Matsubara frequencies, but on a
dense grid. If the approximant is good, then this
should yield a smooth interpolating curve on the Matsubara
axis. On the other hand, little ‘spikes’ are a hint
for pole-zero pairs close to the imaginary axis. This
is usually a result of noise and a different choice of
Matsubara frequencies may help.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>im_axis_fine</strong> (<em>numpy.ndarray</em><em>, </em><em>default=None</em>) – Imaginary-axis points where the approximant is
evaluated for checking. If not specified,
an array of length 500 is generated, which goes
up to twice the maximum frequency that was used
for constructing the approximant.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Values of the Pade approximant at the points
of <cite>im_axis_fine</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.solvers.PadeSolver.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">show_plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.solvers.PadeSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Pade approximation on the real axis.</p>
<p>The main numerically heavy computation is done in the Cython module
<cite>pade.pyx</cite>. Here we just call the functions.
In the Pade method, the numerator and denominator approximants
are generated separately, and then the division is done.
As an additional feature we add the callable <cite>numerator_function</cite>
and <cite>denominator_function</cite> to the OptimizationResult object.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ana_cont.kernels">
<span id="kernels-module"></span><h2><span class="section-number">11.3. </span>Kernels module<a class="headerlink" href="#module-ana_cont.kernels" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="ana_cont.kernels.Kernel">
<em class="property">class </em><code class="sig-prename descclassname">ana_cont.kernels.</code><code class="sig-name descname">Kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">re_axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">im_axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.kernels.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>This class handles the kernel of the analytic continuation.</p>
<p>The kernel matrix is calculated from the real-frequency vector <cite>re_axis</cite>
and the imaginary frequency or time vector <cite>im_axis</cite>.
It is important to note that the Kernel does not know the inverse temperature
beta. In case of the frequency kernels (‘freq_fermionic’ or ‘freq_bosonic’)
the temperature is implicitly contained through the Matsubara frequencies.
In case of the time kernels (‘time_fermionic’ or ‘time_bosonic’) the <cite>im_axis</cite>
list has to be rescaled such that the temperature would be 1. Usually this is done
by <cite>imag_time = imag_time / beta</cite>.</p>
<p>For regular users of the library this is no problem, since the Kernel class is only
instantiated inside the AnalyticContinuationProblem class, where the rescaling is done
automatically. (Also the results are scaled back automatically there.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> (<em>str</em><em>, </em><em>default=None</em>) – Which kind of kernel to use. Possible options:
‘freq_bosonic’, ‘time_bosonic’, ‘freq_bosonic_xyz’,
‘freq_fermionic’, ‘time_fermionic’, ‘freq_fermionic_phsym’,
‘time_fermionic_phsym’</p></li>
<li><p><strong>re_axis</strong> (<em>numpy.ndarray</em><em>, </em><em>default=None</em>) – real-frequency axis to generate the kernel matrix</p></li>
<li><p><strong>im_axis</strong> (<em>numpy.ndarray</em><em>, </em><em>default=None</em>) – imaginary axis (time, Matsubara frequency)
to generate the kernel matrix</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ana_cont.kernels.Kernel.blur">
<code class="sig-name descname">blur</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hidden_spectrum</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.kernels.Kernel.blur" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert hidden spectral function to spectral function.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.kernels.Kernel.convolve_kernel">
<code class="sig-name descname">convolve_kernel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.kernels.Kernel.convolve_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve bosonic or fermionic kernel with a Gaussian.</p>
<p>The Gaussian is <span class="math notranslate nohighlight">\(g(x) = \frac{1}{b \sqrt{2 \pi}} exp(-x^2/(2b^2))\)</span>.
In the fermionic case, the convolution can be written as
<span class="math notranslate nohighlight">\(K_{preblur}(i\nu_n, \omega) = \int_{-5b}^{5b} dx\; \frac{g(x)}{i\nu_n - x - \omega}\)</span></p>
<p>In the bosonic case, the convolution can be written as
<span class="math notranslate nohighlight">\(K_{preblur}(i\omega_n, \nu) = \frac{1}{2} \int_{-5b}^{5b} dx\; g(x) [\frac{(x+\nu)^2 }{ (x+\nu)^2 + \omega_n^2} + \frac{(x-\nu)^2 }{ (x-\nu)^2 + \omega_n^2}]\)</span></p>
<p>Integration over the Gaussian from <span class="math notranslate nohighlight">\(-5b\)</span> to <span class="math notranslate nohighlight">\(5b\)</span> is certainly sufficient.
Thus the Gaussian has to be computed only once and integration by scipy.integrate.simps
gives very accurate results even for tiny values of b.</p>
<p>Note: More direct calculation by, e.g., scipy.integrate.quad is possible but unstable
and extremely slow.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.kernels.Kernel.kernel_matrix">
<code class="sig-name descname">kernel_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.kernels.Kernel.kernel_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the kernel matrix.
If you want to implement another kernel,
you just have to add another ‘elif’ here.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.kernels.Kernel.preblur">
<code class="sig-name descname">preblur</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">blur_width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.kernels.Kernel.preblur" title="Permalink to this definition">¶</a></dt>
<dd><p>Preblur for the kernel, if applicable.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.kernels.Kernel.real_matrix">
<code class="sig-name descname">real_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.kernels.Kernel.real_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return real and imaginary part one after another.</p>
</dd></dl>

<dl class="py method">
<dt id="ana_cont.kernels.Kernel.rotate_to_cov_eb">
<code class="sig-name descname">rotate_to_cov_eb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ucov</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ana_cont.kernels.Kernel.rotate_to_cov_eb" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate first axis of kernel to eigenbasis of covariance matrix.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gui.gui_backend">
<span id="graphical-user-interface"></span><h2><span class="section-number">11.4. </span>Graphical user interface<a class="headerlink" href="#module-gui.gui_backend" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="gui.gui_backend.InputData">
<em class="property">class </em><code class="sig-prename descclassname">gui.gui_backend.</code><code class="sig-name descname">InputData</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">iter_type</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">iter_num</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_type</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">atom</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbital</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">spin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_mats</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ignore_real_part</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.InputData" title="Permalink to this definition">¶</a></dt>
<dd><p>Input data for the analytic continuation of a w2dynamics result.</p>
<p>Initialize the input data object.</p>
<dl class="simple">
<dt>fname – Name (str) of a valid w2dynamics DMFT output file.</dt><dd><p>A w2dynamics version from 2020 or newer should be used.</p>
</dd>
</dl>
<p>iter_type – iteration type: ‘dmft’ or ‘stat’
iter_num – iteration number: integer or ‘last’ (-1 also points to last)
data_type – “Green’s function” or “Self-energy”
atom – which inequivalent atom (one-based integer), e.g. 1 leads to ‘ineq-001’
orbital – which orbital component to load (one-based integer)
spin – which spin projection to load: ‘up’, ‘down’, ‘average’
num_mats – number of Matsubara frequencies for continuation (integer)
ignore_real_part – if True, the real part is set to zero.</p>
<dl class="py method">
<dt id="gui.gui_backend.InputData.generate_mats_freq">
<code class="sig-name descname">generate_mats_freq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.InputData.generate_mats_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Matsubara frequency grid.</p>
</dd></dl>

<dl class="py method">
<dt id="gui.gui_backend.InputData.get_iteration">
<code class="sig-name descname">get_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.InputData.get_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose the whole iteration string, e.g. ‘dmft-003’.</p>
</dd></dl>

<dl class="py method">
<dt id="gui.gui_backend.InputData.load_data">
<code class="sig-name descname">load_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.InputData.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Matsubara-frequency data.</p>
<p>Load w2dynamics data on Matsubara frequency axis.
This is either a self-energy, or a Green’s function.
For the self-energy, there are two different possible formats.</p>
</dd></dl>

<dl class="py method">
<dt id="gui.gui_backend.InputData.load_giw">
<code class="sig-name descname">load_giw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.InputData.load_giw" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Matsubara Green’s function data.</p>
<p>Here we have only one possible format, i.e. (orb, spin, orb, spin, freq).
If no QMC error is present, we set it to a constant value err_const.</p>
</dd></dl>

<dl class="py method">
<dt id="gui.gui_backend.InputData.load_siw_1">
<code class="sig-name descname">load_siw_1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.InputData.load_siw_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Load self-energy with jackknife error, type 1.</p>
<p>In the first implementation, the self-energy with jackknife error
was written in the group ‘siw-full-jkerr’, where the frequency
axis is the first, followed by orbital and spin: (freq, orb, spin, orb, spin)
The Hartree term is subtracted automatically.</p>
</dd></dl>

<dl class="py method">
<dt id="gui.gui_backend.InputData.load_siw_2">
<code class="sig-name descname">load_siw_2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.InputData.load_siw_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Load self-energy with jackknife error, type 2.</p>
<p>In newer versions, the self-energy with jackknife error is stored
in siw-full, in standard format (orb, spin, orb, spin, freq).
If the QMC error is not present, it is set to a constant value err_const.
The Hartree term is subtracted automatically.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gui.gui_backend.OutputData">
<em class="property">class </em><code class="sig-prename descclassname">gui.gui_backend.</code><code class="sig-name descname">OutputData</code><a class="headerlink" href="#gui.gui_backend.OutputData" title="Permalink to this definition">¶</a></dt>
<dd><p>Output data of the analytic continuation.</p>
<dl class="py method">
<dt id="gui.gui_backend.OutputData.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">original_grid</span></em>, <em class="sig-param"><span class="n">original_function</span></em>, <em class="sig-param"><span class="n">n_reg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.OutputData.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Spline interpolation of real-frequency data.</p>
</dd></dl>

<dl class="py method">
<dt id="gui.gui_backend.OutputData.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interpolate</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_reg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.OutputData.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save output data to text file.</p>
<p>Here we have to distinguish several different cases.
* For a self-energy, we first do a Kramers-Kronig transformation</p>
<blockquote>
<div><p>to get also the real part.
Then the Hartree term is added. Remember: when reading input data from a text file,
the Hartree term has to be handeled manually, the program treats it as zero.
The whole function, i.e. real and imaginary part of the self-energy, is saved.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>In case of a Green’s function, we save the spectral function,</dt><dd><p>i.e. -Im[G(omega)] / pi. The real part is not computed.</p>
</dd>
</dl>
</li>
<li><p>If desired, an interpolation to a regular-spaced grid is done.</p></li>
</ul>
<p>Output format: text file.
For spectral function: two colums: frequency, spectrum
For self-energy: three columns: frequency, real part, imaginary part.</p>
</dd></dl>

<dl class="py method">
<dt id="gui.gui_backend.OutputData.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w</span></em>, <em class="sig-param"><span class="n">spec</span></em>, <em class="sig-param"><span class="n">input_data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.OutputData.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the output data with the latest input and results.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gui.gui_backend.RealFrequencyGrid">
<em class="property">class </em><code class="sig-prename descclassname">gui.gui_backend.</code><code class="sig-name descname">RealFrequencyGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.RealFrequencyGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for real-frequency grids.</p>
<p>Our real-frequency grids are always symmetric around 0.
Thus they cover an interval [-wmax, wmax], where the endpoint is included.
If the number of grid-points nw is an odd number, zero is included.
We can create two types of grids: equispaced or non-equispaced (centered).
The  latter is more dense in the low-frequency region, and more
sparse in the high-frequency region.</p>
<p>Initialize the real-frequency grid.</p>
<p>wmax – border of the real-frequency interval [-wmax, wmax]
nw – total number of real frequency grid points
type – grid type: ‘equispaced grid’ or ‘centered grid’</p>
<dl class="py method">
<dt id="gui.gui_backend.RealFrequencyGrid.create_grid">
<code class="sig-name descname">create_grid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.RealFrequencyGrid.create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the real-frequency grid.</p>
<p>There are four possible types of real-frequency grids.
In each case, the endpoint is included in the grid.</p>
<ul class="simple">
<li><p>An ‘equispaced symmetric’ grid is simply a linspace, containing also the endpoint.</p></li>
<li><p>The ‘centered symmetric’ grid is created by a tangent function,
such that the grid points are denser around zero.</p></li>
<li><p>‘equispaced positive’ is a simple linspace, starting from zero
and containing only positive values.</p></li>
<li><p>‘centered positive’ also starts from zero and contains only positive
values, but close to zero they are lying denser.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gui.gui_backend.TextInputData">
<em class="property">class </em><code class="sig-prename descclassname">gui.gui_backend.</code><code class="sig-name descname">TextInputData</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_type</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_mats</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n_skip</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.TextInputData" title="Permalink to this definition">¶</a></dt>
<dd><p>Input data for analytic continuation, from a generic text file.</p>
<p>Initialize the text file input.</p>
<p>fname – file name of the text file
data_type – either “Green’s function” or “Self-energy”
num_mats – number of Matsubara frequencies
n_skip – number of lines to skip at the beginning of the text file.</p>
<p>Note the following points:
* The Hartree term has to be subtracted beforehand,</p>
<blockquote>
<div><p>i.e. both the real and imaginary part of the data in the input file
have to approach zero in the high-frequency limit,</p>
</div></blockquote>
<ul class="simple">
<li><p>The input file must contain only data on the positive half of the Matsubara axis,</p></li>
<li><dl class="simple">
<dt>data_type will not have any impact on the analytic continuation itself,</dt><dd><p>but if it is a self-energy, the real part is calculated by Kramers-Kronig
after the continuation, and the full self-energy is stored.</p>
</dd>
</dl>
</li>
<li><p>The Hartree term has to be handeled completely manually in pre- and postprocessing.</p></li>
</ul>
<dl class="py method">
<dt id="gui.gui_backend.TextInputData.read_data">
<code class="sig-name descname">read_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.TextInputData.read_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the text file by np.loadtxt.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="gui.gui_backend.input_data_plot">
<code class="sig-prename descclassname">gui.gui_backend.</code><code class="sig-name descname">input_data_plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mats</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">error</span></em>, <em class="sig-param"><span class="n">datatype</span></em>, <em class="sig-param"><span class="n">mom1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hartree</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gui.gui_backend.input_data_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a very simple plot of the Matsubara data.</p>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">ana_cont</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">1. Installation of ana_cont</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui.html">2. GUI documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">3. Analytic continuation with the ana_cont library</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">4. Square lattice Hubbard model, <span class="math notranslate nohighlight">\(U=2\)</span>, <span class="math notranslate nohighlight">\(\beta=5\)</span>, half-filling</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html#Strontium-vanadate">5. Strontium vanadate</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html#Analytical-continuation-of-a-matrix-valued-function-(Kagome)">6. Analytical continuation of a matrix-valued function (Kagome)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_svo.html">7. Tutorial: Analytic continuation of SrVO<span class="math notranslate nohighlight">\(_3\)</span> self-energy</a></li>
<li class="toctree-l1"><a class="reference internal" href="preblur_test.html">8. Preblur for fermionic functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="preblur_bosonic.html">9. Preblur for bosonic continuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="poorman_test.html">10. Maxent for matrix-valued Green’s functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. API documentation of ana_cont</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-ana_cont.continuation">11.1. Continuation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ana_cont.solvers">11.2. Solvers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ana_cont.kernels">11.3. Kernels module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gui.gui_backend">11.4. Graphical user interface</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="poorman_test.html" title="previous chapter"><span class="section-number">10. </span>Maxent for matrix-valued Green’s functions</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Josef Kaufmann.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/api_doc.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>